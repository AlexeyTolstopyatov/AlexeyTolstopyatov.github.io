---
layout: post
title: "Исполняемые файлы в DOS"
date:   2025-08-14 18:00:00 +0700
categories: notes 
---

На смену `.COM` файлам (см. [CP/M, DOS, и их COMманды](/posts/2025/08/07/ru/com)) в операционной системе пришли
`.EXE` файлы (полн. "EXEcutable" или "исполняемые"). Сегодня речь пойдет именно об этом.
Поскольку история происходит снова в Microsoft, запутаться с `.EXE`-файлами очень легко.

Во-первых речь пойдет в первую очередь (или преимущественно) о первом формате сегментации, то есть о знаменитом `MZ`-заголовке.
И лишь потом, в конце я объясню "почему так легко запутаться".

### Небольшой обзор

Согласно википедии: 
> .EXE (полн. англ. executable — исполняемый) — расширение исполняемых файлов, применяемое в операционных системах DOS, Windows, Symbian OS, OS/2 и в некоторых других, соответствующее ряду форматов. Кроме объектного кода может содержать различные метаданные (ресурсы, цифровая подпись).

А сама программа `.EXE` в понимании `PC-DOS` это
> Исполняемый файл MS-DOS - это размеченный образ, содержащий в себе таблицы данных, секции кода, данных, и фиксированную точку входа. 

По сравнению с командами это уже не монолит кода. Это вполне себе книга, которая имеет название, содержание и главы.

Я приведу таблицу, и там детальнее покажу все особенности.

| Характеристики                | `.COM`             | `.EXE`           |
|-------------------------------|--------------------|------------------|
| Точка входа                   | Везде (любое место)| Зафиксированна   |
| Максимальный размер           | 64 КБ              | 1 МБ             |
| Структура данных              |                    | Физически разграничен |
| Опознавательные знаки         |                    | Цифровая подпись |
| Область жизни              | Весь файл в одном сегменте | Часть/сегмент файла |

Теперь подробнее объясню смысл идеи "область жизни";
Те кто знаком с `PC/MS-DOS` любым образом, сразу держат в голове факт, что комманда при вызове загружалась в "Program Memory" область и занимала какое-то там место, но помещалась там абсолютно вся. Из любой точки памяти процесса можно было "ткнуть" (или взять указатель) на любое место памяти процесса, без лишних телодвижений. 
В более поздней терминологии компилятора Watcom, это будет называться "НеДалёкие указатели" (англ. "Near Pointers")

Поскольку, размер образ `.EXE` файла может быть значительно больше, (уже за пределами ОЗУ), в ОЗУ полностью он просто не поместится, а в "Program Memory" уж и подавно нет. Спрашивается сразу же: 

**"Что же делать?"**

### Оверлеи

Перед тем, как тронуть спецификацию программы, я обязан описать то, что в этой документации может вызвать примитивные вопросы.

> Overlay - это метод программирования, позволяющий создавать программы, занимающие больше памяти, чем установлено в системе

Метод предполагает разделение программы на фрагменты. Размер каждого оверлея/фрагмента ограничен, согласно размеру доступной памяти. 

Место в памяти, куда будет загружен оверлей называется регионом (region или destination region) _или областью перекрытия_. Хотя часто программы используют только один блок памяти для загрузки различных оверлеев, возможно определение нескольких регионов различного размера. 

Менеджер оверлеев, иногда являющийся частью ОС, подгружает запрашиваемый оверлей из внешней памяти в регион.

Программирование с применением оверлеев требует _очень внимательного_ отношения к размеру каждой части программы. Программирование при помощи оверлеев является более сложным, чем при использовании виртуальной памяти.

Я никогда не пробовал такое делать, но в будущем обязательно вернусь к этому и попробую что-то сделать сам. Пока что я знаю как это работает только в теории.

В `PC-DOS` двоичные файлы, содержащие оверлеи часто имели расширение `.OVL`

### Перемещения

В спецификации исполняемого файла часто фигурирует поняние релокаций.

Скажу так... Иногда, случаются вредные ситуации, когда на этапе сборки программы нельзя совершенно точно сказать адрес области, информацию из которой вы бы хотели знать. 
Отсюда следует потребность в своеобразных уточнениях линкером или сборщиком, "куда конкретно надо подойти?"

> Релокация (англ. "relocation") — это информация о поправках к абсолютным адресам в памяти, созданная компилятором или ассемблером и хранящаяся в файле.


### Типы указателей (не обязательно)

Это можно пропустить, но я зайти немножечко вперед. Согласно документации Borland, физическим (аппаратным) возможностям того времени, и тяжелым временам, в голове должно сложиться приблизительно следующее:
 - Максимальное машинное слово (англ. "CPU WORD") - 16-бит. (времена Intel i8086+);
 - Весьма маленький объем ОЗУ и Program Memory,
 - `.PSP` сегмент (потому что это `PC/MS-DOS`)

Теперь всё просто:
 - Не далёкие указатели (англ. "Near Pointers") - это указатели, которые помещаются в регистр.
 То есть 16-битные.
 - Далёкие указатели (англ. "Far Pointers") - это указатели, которые уже НЕ помещаются в регистр; (почему-то) в два раза больше, или 32-битные. 

Далёкие указатели это не просто адрес куда-то в 32-разрядном размере.
Далёкиё указатель имел обычно форму записи `16:16`, что означало 16 бит адрес, 16 бит номер сегмента.


### Mark Zbikowski Executable Format

Теперь, как один из важных вопросов закрыт, представляю вам то, что вы и без меня знаете.

Буквы `MZ` (шестн. `0x4D 0x5A`) - это инициалы инженера Microsoft, который предложил и представил
альтернативу односегментным `.COM` программам. 

Теперь любая программа имела в себе структуру MZ-заголовка
и её подопечные структуры данных, чтобы хранить информацию
о коде, данных и других жизненно необходимых её частях.

```rust
struct MzHeader{
    // Стандартная (повсеместная) часть заголовка
    pub e_sign: Lu16,       // подпись ZM или MZ
    pub e_cblp: Lu16,       // последний блок
    pub e_cp: Lu16,         // количество блоков/страниц
    pub e_relc: Lu16,       // количество релокаций
    pub e_cparhdr: Lu16,    // размер заголовка в блоках
    pub e_minep: Lu16,      // мин. выделенной памяти  в блоках
    pub e_maxep: Lu16,      // макс. выделенной памяти в блоках
    pub ss: Lu16,
    pub sp: Lu16,
    pub e_check: Lu16,
    pub ip: Lu16,
    pub cs: Lu16,
    pub e_lfarlc: Lu16,      // Сырое смещение таблицы релокаций
    
    // Расширенная/Дополнительная часть MZ-заголовка 
    pub e_ovno: Lu16,        // Текущая .OVL часть.
    pub e_res0x1c: [Lu16; 4],// UInt16[4] линкер/компилятор или мусор
    pub e_oemid: Lu16,
    pub e_oeminfo: Lu16,
    pub e_res_0x28: [Lu16; 10], // UInt16[10] линкер/компилятор/OEM/мусор
    pub e_lfanew: Lu32,         // Пока что равен нулю.
}
```
Пройдусь по некоторым полям, которые мало кто хочет обозначать
 - Префикс `e_` это "executable";
 - `e_minep` и `e_maxep` расшифровываются как минимальное и максимальное значение ожидаемой памяти в блоках (например `e_maxep = maximum expected paragraphs`);
 - `e_ovno` расшифровывается как `overlay's number`, а не количество оверлеев, что напрямую говорит о том, что оверлеи тоже внутри себя хранят расширенный DOS заголовок
    - `0x0000` - Главная программа (`.EXE` файл)
    - `1+` - Оверлей-часть программы (`.EXE` или `.OVL`);
- `e_res0x1C` - массив зарезервированных байт, который долгое время был
выделен для дальнейших полей, но (судя по всему) откладывался;
- `e_res0x28` - массив зарезервированных байт. В "идеальных" файлах является нулевым (везде хранит нули);
- `e_oemid` и `e_oeminfo` практически нигде не задокументированны,
и _возможно_ используются "как попало". Ожидается, что в них хранится уникальный номер и ссылка на информацию от производителя ПО, но эти поля так же не влияют на запуск. 

Более того, `DR-DOS` в OEM полях хранит свои специальные данные.

Теперь скажу свои предположения касаемо загадочных пустот в заголовке.
Много где на форумах я видел, что "якобы компилятор или сборщик мог помечать специальные флаги для себя там". Я полагаю, такое следствие вполне себе может быть, и вполне оправдано, так как эти поля загрузчиком не проверялись. Мало того, эти поля могли быть использованы различным вредоносным ПО.

Исследуя компилятор Open Watcom я не смог найти чего-то интересного для 
MZ заголовка, поэтому подтверждать гипотезу о компиляторах не осмелюсь пока что. А инструменты Borland и Watcom закрыты от глаз пользователей, к моему сожалению.


Поля до `e_ovno` встречаются во всех DOS, поэтому в некоторых кругах
_DOS-заголовок означает только стандартные поля структуры_. 

А название "MZ-заголовок" или _"Расширенный DOS-заголовок" подразумевают сразу же эту самую структуру, дополненную полями_ `e_ovno (overlay's number)`, OEM и `e_lfanew`.

Поле `e_relc` говорит количество релокаций в файле, а поле `e_lfarlc`
переводится как "location `FAR` address relocations" (предположительно).

Таблица релокаций выглядит очень просто:
```rust
struct MzRelocations {
    // Количество записей определяет "e_relc"
    // Формат записи 0000:0000
    pub rec: [Lu32; e_relc],
}
```

Некоторые источники говорят, что небезызвестное поле `e_lfanew`
появилось позже с появлением первого сегментного формата - "New Executable".
Отсюда, собственно и название поля: "`LONG` file address New..." (а дальше продолжите сами).


### Побайтовые сдвиги в уме

Сжатый формат записи `16:16`, который будет преследовать всех ещё очень долго, расшифровывается (разбивается на дважды по 16) немного неочевидно.

Есть какое-то сырое значение вида "сегмент:адрес". Надо каким-то образом сделать кортеж или просто два поля `сегмент` и `адрес`.

```rust
let (segment, offset) = (
    csip >> 16,
    csip & 0xFFFF
);
```
Первая операция выглядит так:

```
целое 32-разрядное поле 
+----+----+----+----+----+----+----+----+
| of | fs | e  | t  |  co|de  | seg|ment|
+----+----+----+----+----+----+----+----+
                    ^
| по-разрядный сдвиг|
+-------------------+
```

Вторая операция выглядит проще. Все, что не равно `0xFF` возвращает 0, поскольку операция byte-OR (или "побитовое ИЛИ") проходит по каждому разряду
в поле и изменяет значение. Значение `0xFFFF0000` это 32-разрядная маска,
которая накладывается и вырезает первую часть поля.

Первые 16 разрядов ИЛИ `0xFF` дадут в результате "ложь", или 0-атом, а любое значение ИЛИ 0 вернет "истину" или 1-атом.

Таким образом поле очистится от мусора из защифрованных смещений.

Формат записи "`rec` из таблицы релокаций" будет выглядеть так:
"`offset:segment`". Потому что архитектура Intel `8086/80286` использует порядок "от младшего к старшему" или LE byte ordering (полн. англ. "Low Endian").

Теперь попробуем впихнуть впихуемое обратно. Как же все-таки сжимались данные до вида `16:16`?

```rust
// при условии, что segment и offset будут 16-разрядными
let segment_offset: u32 = (segment << 4) | offset;
```

### Внимание, разделение

Стоит помнить, что речь идет о временах, когда на уровне двоичных данных
не было понятия "секции"

Ещё очень много лет пройдёт, когда понятие "секции" появится у IBM и Microsoft. Поэтому после заголовков и таблиц релокаций в файле будут разграниченные области, но никаких `.text` или `.data` не будет!

Только начиная с IBM OMF формата (именно LX исполняемого файла), можно думать, что внутри бинарника существует подобие секций. Там фигурируют объекты, и объекты по природе безымянны, то есть не имеют явных имен `.text` и `.bss`, а содержат флаги, указывающие на их предустановленные права. 

Для формата пораньше - Microsoft/IBM OMF (LE исполняемого файла), лучше представлять, что объект это нечто похожее на сегмент данных, как у New Executable формата, потому что там фигурирует смешанный код (16 и 32 разрядный).

### Запуск

> Здесь будет немного математики, но я постараюсь уложить это так, чтобы было проще читать.

В некоторых источниках, говорят, что `PC-DOS 1.0` создавала область
`.PSP` (полн. "Program Segment Prefix") для исполняемых файлов. Я это пропущу мимо, пока что.

Операционной системе для загрузки программы надо знать список важных переменных
1. Размер программы;
2. Начальные Значения регистров для программы;
3. Начальный адрес загрузки образа;
4. MZ-Заголовок;
5. Релокации (исправления к специальным адресам)

Чтобы узнать размер программы (или образа программы), надо немножечко посчитать:

```rust
let image_size = (CS * 512) - (e_cparhdr * 16)
```

Чтобы посчитать точку входа в программу, тоже прийдется посчитать, а не брать сырые значения из заголовка.

```rust
let image_base = dos_psp_offset + e_cparhdr + 0x10
```

Теперь часть посложнее. Поскольку заголовок считан, таблица PSP уже существует, и настроены регистры стэка, прийдется операционной системе посмотреть в таблицу релокаций файла.

Применяет исправления операционная система таким образом:
```rust
let base_address = load_address; // адрес загрузки
for relocation in relocations {
    let target_ptr = base_address + relocation.offset as usize;
    let value = read_u16(target_ptr); // текущее значение
    write_u16(target_ptr, value + base_segment); // запись исправленного адреса
}
```

### Выводы

В целом, сам MZ заголовок и его данные выглядят и расшифровываются не трудно. Основная доля записей посвещалась истории и заметкам "Охотника за указателями".

Проблемы `.EXE` файлов проявляются с каждым форматом их сегментации, а их за время набралось немало.
У каждого формата свои достоинства и недостатки, а определять их можно по первому слову от `e_lfanew` смещения. (То есть указатель в `e_lfanew` покажет расположение следующей цифровой подписи)

А слово (подпись) уже определяет сам формат. Их на данный момент пять:
NE (new executable), LE (linear executable), LX (0S/2 linear eXecutable), PE (portable executable), TE (terse executable). 

