---
layout: post
title: "Исполняемые файлы в DOS"
date:   2025-08-14 18:00:00 +0700
categories: notes 
---

На смену `.COM` файлам (см. [CP/M, DOS, и их COMманды](/posts/2025/08/07/ru/com)) в операционной системе пришли
`.EXE` файлы (полн. "EXEcutable" или "исполняемые"). Сегодня речь пойдет именно об этом.
Поскольку история происходит снова в Microsoft, запутаться с `.EXE`-файлами очень легко.

Во-первых речь пойдет в первую очередь (или преимущественно) о первом формате сегментации, то есть о знаменитом `MZ`-заголовке.
И лишь потом, в конце я объясню "почему так легко запутаться".

### Небольшой обзор

Согласно википедии: 
> .EXE (полн. англ. executable — исполняемый) — расширение исполняемых файлов, применяемое в операционных системах DOS, Windows, Symbian OS, OS/2 и в некоторых других, соответствующее ряду форматов. Кроме объектного кода может содержать различные метаданные (ресурсы, цифровая подпись).

А сама программа `.EXE` в понимании `PC-DOS` это
> Исполняемый файл MS-DOS - это размеченный образ, содержащий в себе таблицы данных, секции кода, данных, и фиксированную точку входа. 

По сравнению с командами это уже не монолит кода. Это вполне себе книга, которая имеет название, содержание и главы.

Я приведу таблицу, и там детальнее покажу все особенности.

| Характеристики                | `.COM`             | `.EXE`           |
|-------------------------------|--------------------|------------------|
| Точка входа                   | Везде (любое место)| Зафиксированна   |
| Максимальный размер           | 64 КБ              | 1 МБ             |
| Структура данных              |                    | Физически разграничен |
| Опознавательные знаки         |                    | Цифровая подпись |
| Область жизни              | Весь файл в одном сегменте | Часть/сегмент файла |

Теперь подробнее объясню смысл идеи "область жизни";
Те кто знаком с `PC/MS-DOS` любым образом, сразу держат в голове факт, что комманда при вызове загружалась в "Program Memory" область и занимала какое-то там место, но помещалась там абсолютно вся. Из любой точки памяти процесса можно было "ткнуть" (или взять указатель) на любое место памяти процесса, без лишних телодвижений. 
В более поздней терминологии компилятора Watcom, это будет называться "НеДалёкие указатели" (англ. "Near Pointers")

Поскольку, размер образ `.EXE` файла может быть значительно больше, (уже за пределами ОЗУ), в ОЗУ полностью он просто не поместится, а в "Program Memory" уж и подавно нет. Спрашивается сразу же: 

**"Что же делать?"**

### Оверлеи

Перед тем, как тронуть спецификацию программы, я обязан описать то, что в этой документации может вызвать примитивные вопросы.

> Overlay - это метод программирования, позволяющий создавать программы, занимающие больше памяти, чем установлено в системе

Метод предполагает разделение программы на фрагменты. Размер каждого оверлея/фрагмента ограничен, согласно размеру доступной памяти. 

Место в памяти, куда будет загружен оверлей называется регионом (region или destination region). Хотя часто программы используют только один блок памяти для загрузки различных оверлеев, возможно определение нескольких регионов различного размера. 

Менеджер оверлеев, иногда являющийся частью ОС, подгружает запрашиваемый оверлей из внешней памяти в регион.

Программирование с применением оверлеев требует _очень внимательного_ отношения к размеру каждой части программы. Программирование при помощи оверлеев является более сложным, чем при использовании виртуальной памяти.

Я никогда не пробовал такое делать, но в будущем обязательно вернусь к этому и попробую что-то сделать сам. Пока что я знаю как это работает только в теории.

В `PC-DOS` двоичные файлы, содержащие оверлеи часто имели расширение `.OVL`

### Перемещения

В спецификации исполняемого файла часто фигурирует поняние релокаций.

Скажу так... Иногда, случаются вредные ситуации, когда на этапе сборки программы нельзя совершенно точно сказать адрес области, информацию из которой вы бы хотели знать. 
Отсюда следует потребность в своеобразных уточнениях линкером или сборщиком, "куда конкретно надо подойти?"

> Релокация (англ. "relocation") — это информация о поправках к абсолютным адресам в памяти, созданная компилятором или ассемблером и хранящаяся в файле.


### Типы указателей (не обязательно)

Это можно пропустить, но я зайти немножечко вперед. Согласно документации Borland, физическим (аппаратным) возможностям того времени, и тяжелым временам, в голове должно сложиться приблизительно следующее:
 - Максимальное машинное слово (англ. "CPU WORD") - 16-бит. (времена Intel i8086+);
 - Весьма маленький объем ОЗУ и Program Memory,
 - `.PSP` сегмент (потому что это `PC/MS-DOS`)

Теперь всё просто:
 - Не далёкие указатели (англ. "Near Pointers") - это указатели, которые помещаются в регистр.
 То есть 16-битные.
 - Далёкие указатели (англ. "Far Pointers") - это указатели, которые уже НЕ помещаются в регистр; (почему-то) в два раза больше, или 32-битные. 

Те кто не знают "почему?", пока что не ищите ответов на вопрос. Это уже слишком _далёко_ от темы. <!-- :D -->

### Mark Zbikowski Executable Format

Теперь, как один из важных вопросов закрыт, представляю вам то, что вы и без меня знаете.

Буквы `MZ` (шестн. `0x4D 0x5A`) - это инициалы инженера Microsoft, который предложил и представил
альтернативу односегментным `.COM` программам. 

Теперь любая программа имела в себе структуру MZ-заголовка
и её подопечные структуры данных, чтобы хранить информацию
о коде, данных и других жизненно необходимых её частях.

```rust
struct MzHeader{
    // Стандартная (повсеместная) часть MZ-заголовка
    pub e_sign: Lu16,       // подпись ZM или MZ
    pub e_cblp: Lu16,       // последний блок
    pub e_cp: Lu16,         // количество блоков/страниц
    pub e_relc: Lu16,       // количество релокаций
    pub e_pars: Lu16,       // количество параграфов
    pub e_minep: Lu16,      // мин. параграфов
    pub e_maxep: Lu16,      // макс. параграфов
    pub ss: Lu16,
    pub sp: Lu16,
    pub e_check: Lu16,
    pub ip: Lu16,
    pub cs: Lu16,
    pub e_lfarlc: Lu16,      // Сырое смещение таблицы релокаций
    
    // Расширенная/Дополнительная часть MZ-заголовка 
    pub e_ovno: Lu16,        // Текущая .OVL часть.
    pub e_res0x1c: [Lu16; 4],// UInt16[4] линкер/компилятор или мусор
    pub e_oemid: Lu16,
    pub e_oeminfo: Lu16,
    pub e_res_0x28: [Lu16; 10], // UInt16[10] линкер/компилятор/OEM/мусор
    pub e_lfanew: Lu32,
}
```

Поля до `e_ovno` встречаются во всех DOS, поэтому в некоторых кругах
DOS-заголовок могут называть именно так. 

А название "MZ-заголовок" или "Расширенный DOS-заголовок" подразумевают сразу же эту самую структуру, дополненную полями `e_ovno (overlay's number)`, OEM и `e_lfanew (пока что должен быть равен 0)`.

Поле `e_relc` говорит количество релокаций в файле, а поле `e_lfarc`
переводится как "`LONG` file address relocations" (предположительно).

Таблица релокаций выглядит очень просто:
```rust
struct MzRelocations {
    // Количество записей определяет "e_relc"
    // Формат записи 0000:0000
    pub rec: [Lu32; e_relc],
}
```

Некоторые источники говорят, что небезызвестное поле `e_lfanew`
появилось позже с появлением первого сегментного формата - "New Executable".
Отсюда, собственно и название поля: "`LONG` file address New..." (а дальше продолжите сами).


### Побайтовые сдвиги в уме

Сжатый формат записи `16:16`, который будет преследовать всех ещё очень долго, расшифровывается (разбивается на дважды по 16) немного неочевидно.

Есть какое-то сырое значение вида "сегмент:адрес". Надо каким-то образом сделать кортеж или просто два поля `сегмент` и `адрес`.

```rust
let (segment, offset) = (
    csip >> 16,
    csip & 0xFFFF0000
);
```
Первая операция выглядит так:

```
целое 32-разрядное поле 
+----+----+----+----+----+----+----+----+
| of | fs | e  | t  |  co|de  | seg|ment|
+----+----+----+----+----+----+----+----+
                    ^
| по-разрядный сдвиг|
+-------------------+
```

Вторая операция выглядит проще. Все, что не равно `0xFF` возвращает 0, поскольку операция byte-OR (или "побитовое ИЛИ") проходит по каждому разряду
в поле и изменяет значение. Значение `0xFFFF0000` это 32-разрядная маска,
которая накладывается и вырезает первую часть поля.

Первые 16 разрядов ИЛИ `0xFF` дадут в результате "ложь", или 0-атом, а любое значение ИЛИ 0 вернет "истину" или 1-атом.

Таким образом поле очистится от мусора из защифрованных смещений.

Формат записи "`rec` из таблицы релокаций" будет выглядеть так:
"`offset:segment`". Потому что IA-32 (или x86) использует порядок "от младшего к старшему" или LE byte ordering (полн. англ. "Low Endian").

### Внимание, разделение

Стоит помнить, что речь идет о временах, когда на уровне двоичных данных
не было понятия "секции"

Ещё очень много лет пройдёт, когда понятие "секции" появится у IBM и Microsoft. Поэтому после заголовков и таблиц релокаций в файле будут разграниченные области, но никаких `.text` или `.data` не будет!


### Выводы

В целом, сам MZ заголовок и его данные выглядят и расшифровываются не трудно. Основная доля записей посвещалась истории и заметкам "Охотника за указателями".

Проблемы `.EXE` файлов проявляются с каждым форматом их сегментации, а их за время набралось немало.
У каждого формата свои достоинства и недостатки, а определять их можно по первому слову от `e_lfanew` смещения. (То есть указатель в `e_lfanew` покажет расположение следующей цифровой подписи)

А слово (подпись) уже определяет сам формат. Их на данный момент пять:
NE (new executable), LE (linear executable), LX (0S/2 linear eXecutable), PE (portable executable), TE (terse executable). 

