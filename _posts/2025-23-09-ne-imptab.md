---
layout: post
title: "NE-Executable | Importing modules and Procedures"
date:   2025-09-23 12:02:00 +0700
categories: notes 
---


This note is a next part of notes-cycle about Microsoft NE format
for Windows 1.x/3.x and OS/2 1.x programs.
This part contains more information about importing procedures, 
and modules in NE Windows executable format.

I've specially decided to write this article strongly after all experiments.
I could have done it six months ago if I didn't respect you. 
Because all my words must have proofs. And after all experiments with Microsoft `LINK.EXE`
and Open Watcom 1.8, I'm ready to declare and determine all interesting things
what I've found.

### Remember the base

The segmented New Executable format is a first Microsoft solution which
allows you to run programs in Intel `80286+ Protected Mode`. 
Starts from `Protected Mode` the memory organization was the different.

All DOS executables (`MZ Executables`) works in `Real Mode` and have 
special memory characteristics. 

For now (since 1985 year, as you know) the `Microsoft Windows 1.01` was released.
And the Microsoft Windows 1.01 was the second well-known source which active uses the
New Executable segmented modules. (First source was a multitasking `MS-DOS 4.0`).

Modern therminology like an "Import" or "Export" in binary structures didn't exist.
Exporting procedures was read from `.DEF` file and rewrote as binary records inside the module by the linker.
Exporting procedures has own name in "Resident" or "Not resident names" table, and the raw address has been in `EntryTable`.

This idea was fully described in previous article.
In this artile I want describe little more the process of 16-bit import.

### Import Modules Table | Overview

The Importing Modules table have a `e_imptab` value in the NE header.
This is a relative offset starting from NE Header.

```rust
let real_imptab: u16 = e_lfanew + e_imptab;
```

The Importing Modules are the strings in `Resident Names` table by the `@0`
ordinal. Name of dynamically linked library in file system may be different.

`dosca11s.dll` may contain `DOSCALLS` string by `@0` and exactly this name
is a module name.

The "Importing Modules Table" is a sequence of `ASCII` (not terminated) starting with special `BYTE`
which tells count of bytes in the following `C` string.

Let's look inside the Microsoft documentation: 

```
The imported-name table follows the module-reference table. This table 
contains the names of modules and procedures that are imported by the 
executable file. Each entry is composed of a 1-byte field that 
contains the length of the string, followed by any number of 
characters. The strings are not null-terminated and are case 
sensitive.
```

The importing names table has a following format 

```
BYTE     Length of the name string that follows. 
BYTE     ASCII text of the name string.
```

And let's retranslate this structure to Rust pseudo code.

```rust
struct ImportRecord {
    pub e_cbname: u8,
    pub e_name: [cb_name, u8],
}
```

Great! You may think about "you can read imports now!". But get it slow... really.
Unfortunately, it's not that simple, which is why I'm going to explain the unsaid words from the documentation.


### Importing Modules Table | `LINK.EXE` and the Patience 

I've specially decided to not start with `Module References table` just because I really
want to demonstrate all ambigous Microsoft `LINK.EXE` behavior.
If I were based on Microsoft documentation, I would never be able to read the imports correctly in my life.

First cannonical thing, which I've found is a naming corruption.
The previous article about exports tells more about this phemonemon. 
I'll just tell it again. All resolved imports in the next will be `UPPERCASE`.
And this is sad (but true). I suppose, this trouble concrete bound with exporting process.
All procedures, what the application (in example `CLOCK.EXE`) requires, are the parts of Windows API,
which store in `KERNEL`, `GDI`, `USER` executable modules.

As far as I know, toolkit for them was the Microsoft Macro Assembler (shorten `MASM`)
and the Microsoft Linker. This will come back to us when we're analyzing the binary content.

Story with the IBM `OS/2 1.0+` unfortunately the same. Toolkit for Win-OS/2 middleware
and the `Win16` applications was made by Microsoft. (evil `LINK.EXE` is knocking again)

Second thing which I want to declare is an ambigous filling of table.
If you carefully read the Microsoft docs about it, you will define that 
names in the table follows one by one.  
**This is not true again!**

Microsoft linker bases on another logic and this idea on the practice (if you will try to read imports)
become a reason of strings tuncation or an incorrect unsafe strings (data may contains unreadable ASCII codes).

### Importing Modules Table | How to see it?

Let's look inside the binary for an answer.
I represent you a specially "corrupted" variant of "Import Modules Table".

```
00xx:0000 00 00 04 4D 41 53 4D 03   4E 45 53[00 00 00 00 00    | ...MASM.NLS.....
00xx:0000 00  |  | ..           |     ]06 4D  | 52 4E 45 4C    | ..........KERNEL
              |  |              |       |     |
              +-------> Head of import table. |
                 |      The sequence of names starts
                 |      strongly from zero. This is
                 |      a good flag to determine start. 
                 |              |       |     |
                 +----> Count of chars in the Pascal string.
                                              |
                                              +--> Padding?!  
```

This is a working example of importing modules table for real.
But _unknown padding_ which nobody wants to see is reason
of data turncation.

My assumptions about this padding are probably wrong, 
but they are there, and they will help you read the table correctly.

```
My ideas about this padding are spinning around the per-segment relocations
just because names offsets in the case of "Import by Name" fixups don't actually
known at the "one" linkage step. Linker makes the reserved space with unknown
for me data (in example count of ordinals per the segment)
```

### Module References Table | Overview

The main tool in your hands is a module references table.
It locates at the `e_modtab` value and relative too.
Following this ~~annoying~~ logic here is a `NEAR` pointer

```rust
let real_modtab: u16 = e_lfanew + e_modtab;
```
Count of records in the module references table describes by the `e_cbmod`
in NE header. Be carefully: This is exactly count of `WORD` records.
I don't know WHY? But for this you better know the `b` means _not `BYTE`s_ and _not bundles_ and not an actually size of table at all.
This is a _count of the offsets in the table_

That's all. Module References Table is a list of an offsets which
enumerates from one.

```rust
struct ModuleReferenceRecord {
    pub e_modoff: u16;
}
```

Here is an example taken from Sunflower

| Index:2     | Offset:2    |
|-------------|-------------|
| 1           | 0x0001      |
| 2           | 0x0006      |
| 3           | 0x0013      |

Offsets in the module reference table are relative too. Starts from beginning of 
`imptab`.

```rust
let real_mod_by_index: u16 = e_lfanew + e_imptab + modtab[index - 1];
```

Then, you firstly must know the module references instead of importing names.
It helps you avoid unexpected paddings.

### Where is Importing Procedures hidden? | Microsoft `LINK.EXE` knows more than me...?

This part of an article the most interesting, I suppose. 

You can send the Microsoft `PDF`s to the DeepSeek or another
LLM with deep analysis by the source. Unfortunately for you, all what it suggest will be wrong. And all those suggestions will be wrong only by the one Microsofts logic issue.

For real there are two ways to resolve importing procedures exactly.
1. Static Imports resolving due `0x80` high byte;
2. Per-segment Relocations filtering.

First way I prefer to completely avoid just because results of this
experiment always different and unsafe. (Any OS/2 binary could crash the editor after call). But Win16 applications resolves successfully.

I've found this way very hard and advise you to follow by the second way.

Second way strongly requires by you the understanding of per-segment relocations.
Please open the previous articles about it, because the next information
strictly depends on it.

### Per-Segment relocations and Imports | My helping hand

As you remember, there are 2 huge sources of information:
 - EntryTable (with Non/Resident Names);
 - Segments and Per-segment relocations.

Let's look deeper inside the per-segment relocations.
I'm going to call Sunflower for this



### Segments Table

The segment table contains an entry for each segment in the executable file.
 The number of segment table entries are defined in the segmented EXE header
. The first entry in the segment table is segment number 1. The following is the structure of a segment table entry. 
| Type:s   | #Segment:4   | Offset:2   | Length:2   | Flags:2   | Minimum Allocation:2   | Characteristics:s   |
|----------|------------|----------|----------|---------|----------------------|---------------------|
| .CODE    | 0x1          | 0x1        | 0x5BCA     | 0xD00     | 0x5BCA                 |                     |
| .CODE    | 0x2          | 0x30       | 0x6388     | 0xD00     | 0x6388                 |                     |
| .CODE    | 0x3          | 0x63       | 0x41A4     | 0xD00     | 0x41A4                 |                     |
| .CODE    | 0x4          | 0x85       | 0x1FB9     | 0xD00     | 0x1FB9                 |                     |
| .CODE    | 0x5          | 0x96       | 0x1CBF     | 0xD00     | 0x1CBF                 |                     |
| .DATA    | 0x6          | 0xA5       | 0x1191     | 0xD41     | 0x3430                 | HAS_MASK PRELOAD    |

```md

### Relocations Table for Segment #1 (.CODE)

The location and size of the per-segment data is defined in the segment table entry for the segment. If the segment has relocation fixups, as defined in the segment table entry flags, they directly follow the segment data in the file.
| ATP:1   | RTP:1   | RTP:s        | IsAdditive:f   | OffsetInSeg:2   | SegType:2   | Target:2   | TargetType:s   | Mod#:2   | Name:2   | Ordinal:2   | Fixup:s   |
|-----------|---------|--------------|----------------|---------------|-------------|------------|----------------|----------|----------|-----------|-----------|
| 0x2     | 0x0     | [Internal]   | [False]        | 0x598A          | 1           | 0x0        | [MOVABLE]      | 0x0      | @0       | 0x0         |           |
| 0x2     | 0x0     | [Internal]   | [False]        | 0x5B13          | 2           | 0x0        | [MOVABLE]      | 0x0      | @0       | 0x0         |           |
| 0x3     | 0x1     | [Import]     | [False]        | 0x57AB          | 0           | 0x0        | []             | 0x2      | @120     | 0x0         |           |
| 0x2     | 0x0     | [Internal]   | [False]        | 0x24C5          | 3           | 0x0        | [MOVABLE]      | 0x0      | @0       | 0x0         |           |
| 0x2     | 0x0     | [Internal]   | [False]        | 0x5AB5          | 4           | 0x0        | [MOVABLE]      | 0x0      | @0       | 0x0         |           |
| 0x3     | 0x2     | [Import]     | [False]        | 0x2F62          | 0           | 0x0        | []             | 0x1      | @0       | 0x8         |           |
| 0x3     | 0x1     | [Import]     | [False]        | 0x4967          | 0           | 0x0        | []             | 0x1      | @8       | 0x0         |           |
| 0x3     | 0x1     | [Import]     | [False]        | 0x4DB1          | 0           | 0x0        | []             | 0x2      | @130     | 0x0         |           |
| 0x3     | 0x1     | [Import]     | [False]        | 0x49A9          | 0           | 0x0        | []             | 0x2      | @2       | 0x0         |           |
| 0x2     | 0x0     | [Internal]   | [False]        | 0x4E11          | 5           | 0x0        | [MOVABLE]      | 0x0      | @0       | 0x0         |           |
| 0x3     | 0x1     | [Import]     | [False]        | 0x3164          | 0           | 0x0        | []             | 0x1      | @14      | 0x0         |           |
| 0x3     | 0x1     | [Import]     | [False]        | 0x56FA          | 0           | 0x0        | []             | 0x2      | @137     | 0x0         |           |
| 0x3     | 0x1     | [Import]     | [False]        | 0x309A          | 0           | 0x0        | []             | 0x1      | @17      | 0x0         |           |
| 0x3     | 0x1     | [Import]     | [False]        | 0x493C          | 0           | 0x0        | []             | 0x2      | @10      | 0x0         |           |
| 0x3     | 0x1     | [Import]     | [False]        | 0x57EE          | 0           | 0x0        | []             | 0x2      | @138     | 0x0         |           |
| 0x3     | 0x1     | [Import]     | [False]        | 0x2E63          | 0           | 0x0        | []             | 0x2      | @144     | 0x0         |           |
| 0x3     | 0x1     | [Import]     | [False]        | 0x2098          | 0           | 0x0        | []             | 0x3      | @9       | 0x0         |           |
| 0x3     | 0x1     | [Import]     | [False]        | 0x450B          | 0           | 0x0        | []             | 0x4      | @1       | 0x0         |           |
| 0x3     | 0x1     | [Import]     | [False]        | 0x48EC          | 0           | 0x0        | []             | 0x3      | @10      | 0x0         |           |
| 0x5     | 0x0     | [Internal]   | [False]        | 0x126E          | 1           | 0x8300     | [MOVABLE]      | 0x0      | @0       | 0x0         |           |
| 0x3     | 0x1     | [Import]     | [False]        | 0x4917          | 0           | 0x0        | []             | 0x3      | @11      | 0x0         |           |
| 0x3     | 0x1     | [Import]     | [False]        | 0x534           | 0           | 0x0        | []             | 0x2      | @151     | 0x0         |           |
| 0x3     | 0x1     | [Import]     | [False]        | 0x4AF3          | 0           | 0x0        | []             | 0x6      | @1       | 0x0         |           |
| 0x3     | 0x1     | [Import]     | [False]        | 0x523D          | 0           | 0x0        | []             | 0x2      | @34      | 0x0         |           |
| 0x3     | 0x1     | [Import]     | [False]        | 0x392A          | 0           | 0x0        | []             | 0x2      | @163     | 0x0         |           |
| 0x3     | 0x1     | [Import]     | [False]        | 0x4E2A          | 0           | 0x0        | []             | 0x2      | @164     | 0x0         |           |
| 0x3     | 0x1     | [Import]     | [False]        | 0x52C6          | 0           | 0x0        | []             | 0x2      | @39      | 0x0         |           |
| 0x3     | 0x1     | [Import]     | [False]        | 0x2F8C          | 0           | 0x0        | []             | 0x6      | @8       | 0x0         |           |
| 0x5     | 0x0     | [Internal]   | [False]        | 0x12A6          | 1           | 0x9C00     | [MOVABLE]      | 0x0      | @0       | 0x0         |           |
| 0x5     | 0x0     | [Internal]   | [False]        | 0x200           | 2           | 0xFD00     | [MOVABLE]      | 0x0      | @0       | 0x0         |           |
| 0x3     | 0x1     | [Import]     | [False]        | 0x25E9          | 0           | 0x0        | []             | 0x7      | @7       | 0x0         |           |
| 0x3     | 0x1     | [Import]     | [False]        | 0x2557          | 0           | 0x0        | []             | 0x7      | @9       | 0x0         |           |
| 0x3     | 0x1     | [Import]     | [False]        | 0x5787          | 0           | 0x0        | []             | 0x2      | @53      | 0x0         |           |
| 0x3     | 0x1     | [Import]     | [False]        | 0x265D          | 0           | 0x0        | []             | 0x7      | @15      | 0x0         |           |
| 0x3     | 0x1     | [Import]     | [False]        | 0x5575          | 0           | 0x0        | []             | 0x2      | @57      | 0x0         |           |
| 0x3     | 0x1     | [Import]     | [False]        | 0x5791          | 0           | 0x0        | []             | 0x2      | @59      | 0x0         |           |
| 0x3     | 0x1     | [Import]     | [False]        | 0x58D7          | 0           | 0x0        | []             | 0x7      | @21      | 0x0         |           |
| 0x3     | 0x1     | [Import]     | [False]        | 0x5909          | 0           | 0x0        | []             | 0x7      | @22      | 0x0         |           |
| 0x3     | 0x1     | [Import]     | [False]        | 0x4FE3          | 0           | 0x0        | []             | 0x2      | @63      | 0x0         |           |
| 0x3     | 0x1     | [Import]     | [False]        | 0x23D0          | 0           | 0x0        | []             | 0x7      | @27      | 0x0         |           |
| 0x5     | 0x0     | [Internal]   | [False]        | 0x12BF          | 1           | 0xB500     | [MOVABLE]      | 0x0      | @0       | 0x0         |           |
| 0x3     | 0x1     | [Import]     | [False]        | 0x576B          | 0           | 0x0        | []             | 0x2      | @70      | 0x0         |           |
| 0x3     | 0x1     | [Import]     | [False]        | 0x5538          | 0           | 0x0        | []             | 0x2      | @71      | 0x0         |           |
| 0x3     | 0x1     | [Import]     | [False]        | 0x2408          | 0           | 0x0        | []             | 0x7      | @32      | 0x0         |           |
| 0x3     | 0x1     | [Import]     | [False]        | 0x54EA          | 0           | 0x0        | []             | 0x2      | @72      | 0x0         |           |
| 0x3     | 0x1     | [Import]     | [False]        | 0x43D0          | 0           | 0x0        | []             | 0x2      | @73      | 0x0         |           |
| 0x3     | 0x1     | [Import]     | [False]        | 0x52AC          | 0           | 0x0        | []             | 0x2      | @74      | 0x0         |           |
| 0x3     | 0x1     | [Import]     | [False]        | 0x42ED          | 0           | 0x0        | []             | 0x2      | @75      | 0x0         |           |
| 0x3     | 0x1     | [Import]     | [False]        | 0x5495          | 0           | 0x0        | []             | 0x2      | @77      | 0x0         |           |
| 0x3     | 0x1     | [Import]     | [False]        | 0x4DCD          | 0           | 0x0        | []             | 0x7      | @40      | 0x0         |           |
| 0x3     | 0x1     | [Import]     | [False]        | 0x43A4          | 0           | 0x0        | []             | 0x2      | @81      | 0x0         |           |
| 0x3     | 0x1     | [Import]     | [False]        | 0x43ED          | 0           | 0x0        | []             | 0x2      | @82      | 0x0         |           |
| 0x3     | 0x1     | [Import]     | [False]        | 0x256E          | 0           | 0x0        | []             | 0x7      | @46      | 0x0         |           |
| 0x3     | 0x1     | [Import]     | [False]        | 0x2620          | 0           | 0x0        | []             | 0x7      | @48      | 0x0         |           |
| 0x5     | 0x0     | [Internal]   | [False]        | 0x12B9          | 1           | 0xCE00     | [MOVABLE]      | 0x0      | @0       | 0x0         |           |
| 0x3     | 0x1     | [Import]     | [False]        | 0x5081          | 0           | 0x0        | []             | 0x2      | @95      | 0x0         |           |
| 0x3     | 0x1     | [Import]     | [False]        | 0x546D          | 0           | 0x0        | []             | 0x2      | @98      | 0x0         |           |
| 0x5     | 0x0     | [Internal]   | [False]        | 0x1274          | 1           | 0x5800     | [MOVABLE]      | 0x0      | @0       | 0x0         |           |
```

You see many records registered and interpret by Sunflower as `[Import]`
Look at the table and find `[Import]` records with zero-ordinal (`@0`).
Those records will be imports by name. Other imports having non-zero ordinal
are imports by ordinal.

Main idea of this algorithm bases on the fact that "Ordinals in Relocations table already set".
Troubles what you may have to implement it - 
1. Position of Module Name;
2. Position of Procedure Name.

So, select all imports which marked as `[Import]` and have relocation 
type equals `IMPORT_BY_NAME` or `IMPORT_ORDINAL`.

To find module name you must:

1. Calculate the offset `e_lfanew + e_modtab + 2 * (relocation.ModuleIndex - 1)` and seek to it.
2. Read `u16` module Name Offset. `dll_name_offset`
3. Calculate the offset `e_lfanew + e_imptab + dll_name_offset` and seek to it.
4. Read the Pascal string (one `u8` of length, that many bytes of character data) at that location. (Make sure to add the NUL terminator at the end of the string if you are using Pascal strings with C string functions)
5. Seek to the location remembered in the first step.

To find the procedure name (import by name): 
To find the procedure name for an IMPORT_NAME relocation, do the following:

1. Calculate the offset `e_lfanew + e_imptab + relocation.NameOffset` and seek to it.
Read the Pascal string (one `u8` of length, that many bytes of character data) at that location. (Make sure to add the NUL terminator at the end of the string if you are using Pascal strings with C string functions!)
Seek to the location remembered in the first step.

As you see, this idea requires filled correctly per-segment relocations already.

I suppose the Ghidra bases on the same algorithm but also holds
special libraries or data files with symbols. That may be a reason of
more informative output (`USER!FatalExit / @1` instead of (`USER!@1`))

In the 2.0.0.0 build of Sunflower the "Sunflower.Ne" plugin has an error of bytes reinterpretation for relocations.
In 2.1.0.0 I've fixed it and completely see the imports.

Let's see _the part of results_ of this procedure

```md
### Resolved Imports of `SESMGR`

16-bit Imports processor bases at per-segment relocations. If segment has special bit in the byte-mask, next services will iterate preprocessed relocations records
| Name               | Ordinal   |
|--------------------|-----------|
| `@14`              | @14       |
| `@17`              | @17       |
| `@8`               | @8        |
| `DOSSMPMPRESENT`   | @0        |
| `DOSSMSETTITLE`    | @0        |

### Resolved Imports of `KBDCALLS`

16-bit Imports processor bases at per-segment relocations. If segment has special bit in the byte-mask, next services will iterate preprocessed relocations records
| Name    | Ordinal   |
|---------|-----------|
| `@10`   | @10       |
| `@11`   | @11       |
| `@13`   | @13       |
| `@4`    | @4        |
| `@5`    | @5        |
| `@9`    | @9        |

### Resolved Imports of `MSG`

16-bit Imports processor bases at per-segment relocations. If segment has special bit in the byte-mask, next services will iterate preprocessed relocations records
| Name   | Ordinal   |
|--------|-----------|
| `@1`   | @1        |
| `@2`   | @2        |

### Resolved Imports of `QUECALLS`

16-bit Imports processor bases at per-segment relocations. If segment has special bit in the byte-mask, next services will iterate preprocessed relocations records
| Name   | Ordinal   |
|--------|-----------|
| `@1`   | @1        |
| `@8`   | @8        |

```